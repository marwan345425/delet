import os
import asyncio
from datetime import datetime
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from fastapi import FastAPI
import uvicorn

# --- Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ ---
api_id = 22575615
api_hash = "c77e3b35d6b1b2b35b35020d69077d8d"
string_session = "1BJWap1sBuwobNG23aASuu7R-lDCKPyydLh7tFLWHS_jHL4CWOVFDlw-8enulQfifvYKuJZkyq8Y03kWdjSVWJKKAL6iRGbZrspxxULh2RJ0Dw_Ex0CHvPGWqvIfCm5sPnKSeqdhs9N8QaWOiU_uFg55m2MkJe5z19BmADxBhp6OYu34lYS_mzZ2AdM8j81-hvQT-_sIwXPlWMER4CuYMGcOBXekPd02IYqiwue7LJfvWhtJyu4Di4KuL_PNIHrYke792uANKXaOVbKZEU7YDQLZ95ZqqSUFOL2rJx-FKkjIq_Ro4EqznaAjadCikgBx09htJNplsPh8RlSPuTZQDupwcusxZWGg="

forward_to_bot = "@Messagedelet_bot"  # Ø¨ÙˆØª ØªØ³ØªÙ‚Ø¨Ù„ Ø¹Ù„ÙŠÙ‡ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª

client = TelegramClient(StringSession(string_session), api_id, api_hash)

messages_store = {}

app = FastAPI()

# ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙˆÙ‚Øª
def format_time(dt):
    return dt.strftime("%Y-%m-%d %H:%M:%S")

def format_msg_info(sender, message, prefix=""):
    name = sender.first_name if sender and sender.first_name else "Ù…Ø¬Ù‡ÙˆÙ„"
    username = f"@{sender.username}" if sender and sender.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
    time_str = format_time(message.date) if message and message.date else "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"
    header = f"{prefix} Ù…Ù†: {name}\n"
    content = message.text or "[Ù…Ø­ØªÙˆÙ‰ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…]"
    footer = f"\nØ§Ù„ÙŠÙˆØ²Ø±: {username}\nØ§Ù„ÙˆÙ‚Øª: {time_str}"
    return header + content + footer

async def send_message_to_bot(text):
    await client.send_message(forward_to_bot, text)

@client.on(events.NewMessage(incoming=True))
async def on_new_message(event):
    if not event.is_private or (event.sender and event.sender.bot):
        return
    sender = await event.get_sender()
    messages_store[event.message.id] = event.message
    # Ù‡Ù†Ø§ Ù…Ù…ÙƒÙ† ØªØ¨Ø¹Øª Ø¥Ø´Ø¹Ø§Ø± Ù„Ùˆ ØªØ¨ÙŠ
    # await send_message_to_bot(format_msg_info(sender, event.message, "Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©"))

@client.on(events.MessageEdited)
async def on_message_edited(event):
    if not event.is_private or (event.sender and event.sender.bot):
        return
    sender = await event.get_sender()
    old_msg = messages_store.get(event.message.id)
    new_msg = event.message
    if not old_msg:
        old_text = "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"
    else:
        old_text = old_msg.text or "[Ù…Ø­ØªÙˆÙ‰ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…]"
    new_text = new_msg.text or "[Ù…Ø­ØªÙˆÙ‰ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…]"
    text = f"ğŸ“ ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø±Ø³Ø§Ù„Ø© Ù…Ù†: {sender.first_name or 'Ù…Ø¬Ù‡ÙˆÙ„'}\n\n" \
           f"Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù‚Ø¨Ù„ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„:\n{old_text}\n\n" \
           f"Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„:\n{new_text}\n\n" \
           f"Ø§Ù„ÙŠÙˆØ²Ø±: @{sender.username if sender.username else 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}\n" \
           f"Ø§Ù„ÙˆÙ‚Øª: {format_time(new_msg.date)}"
    await send_message_to_bot(text)
    messages_store[event.message.id] = new_msg

@client.on(events.MessageDeleted)
async def on_message_deleted(event):
    for msg_id in event.deleted_ids:
        old_msg = messages_store.get(msg_id)
        if not old_msg or not old_msg.is_private:
            continue
        sender = await old_msg.get_sender()
        text = old_msg.text or "[Ù…Ø­ØªÙˆÙ‰ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…]"
        notif = f"ğŸ—‘ ØªÙ… Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ù…Ù†: {sender.first_name if sender else 'Ù…Ø¬Ù‡ÙˆÙ„'}\n\n" \
                f"Ø§Ù„Ù…Ø­ØªÙˆÙ‰:\n{text}\n\n" \
                f"Ø§Ù„ÙŠÙˆØ²Ø±: @{sender.username if sender and sender.username else 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}\n" \
                f"Ø§Ù„ÙˆÙ‚Øª: {format_time(old_msg.date)}"
        await send_message_to_bot(notif)
        messages_store.pop(msg_id, None)

@app.get("/")
def read_root():
    return {"status": "Bot is running"}

async def main():
    await client.start()
    print("Userbot started")
    # ØªØ´ØºÙ„ Uvicorn Ù„Ø®Ø¯Ù…Ø© FastAPI Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙˆØ±Øª 10000
    config = uvicorn.Config(app, host="0.0.0.0", port=10000, log_level="info")
    server = uvicorn.Server(config)
    await asyncio.gather(client.run_until_disconnected(), server.serve())

if __name__ == "__main__":
    asyncio.run(main())
