import os
import asyncio
from datetime import datetime
from flask import Flask
from threading import Thread
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from telethon.tl.types import MessageMediaPhoto, MessageMediaDocument, DocumentAttributeAudio, DocumentAttributeVideo

# --- Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ Ø§Ù„Ø®Ø§ØµØ© ---
api_id = 22575615
api_hash = "c77e3b35d6b1b2b35b35020d69077d8d"
string_session = "1BJWap1sBuwobNG23aASuu7R-lDCKPyydLh7tFLWHS_jHL4CWOVFDlw-8enulQfifvYKuJZkyq8Y03kWdjSVWJKKAL6iRGbZrspxxULh2RJ0Dw_Ex0CHvPGWqvIfCm5sPnKSeqdhs9N8QaWOiU_uFg55m2MkJe5z19BmADxBhp6OYu34lYS_mzZ2AdM8j81-hvQT-_sIwXPlWMER4CuYMGcOBXekPd02IYqiwue7LJfvWhtJyu4Di4KuL_PNIHrYke792uANKXaOVbKZEU7YDQLZ95ZqqSUFOL2rJx-FKkjIq_Ro4EqznaAjadCikgBx09htJNplsPh8RlSPuTZQDupwcusxZWGg="

client = TelegramClient(StringSession(string_session), api_id, api_hash)

# Ø³ÙŠØ±ÙØ± ØµØºÙŠØ± Ø¹Ø´Ø§Ù† Replit Ù…Ø§ ÙŠØ·ÙÙ‰
app = Flask('')

@app.route('/')
def home():
    return "I'm alive!"

def run():
    app.run(host='0.0.0.0', port=8080)

def keep_alive():
    t = Thread(target=run)
    t.start()

# ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ù„ØªØªØ¨Ø¹ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª ÙˆØ§Ù„Ø­Ø°Ù)
messages_dict = {}

# ÙŠÙˆØ²Ø± Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù„ÙŠ ØªØ¨ØºÙ‰ ØªØ±Ø³Ù„ Ù„Ù‡ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª (ØºÙŠØ±Ù‡ Ù‡Ù†Ø§)
forward_to_user = "@Leeo71"  # Ù…Ø«Ù„Ø§Ù‹ Ù‡Ø°Ø§ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù„ÙŠ ØªØ¨ÙŠ ØªÙˆØµÙ„Ù‡ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„

# Ø¯Ø§Ù„Ø© ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„ÙˆÙ‚Øª
def format_datetime(ts):
    return ts.strftime("%Y-%m-%d %H:%M:%S")

# Ø¯Ø§Ù„Ø© ØªØ±Ø¬Ø¹ Ù†Øµ ÙˆØµÙ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
def get_content_text(message):
    if message.media:
        if isinstance(message.media, MessageMediaPhoto):
            return "[ØµÙˆØ±Ø©]"
        elif isinstance(message.media, MessageMediaDocument):
            attrs = message.media.document.attributes
            if any(isinstance(attr, DocumentAttributeVideo) for attr in attrs):
                return "[ÙÙŠØ¯ÙŠÙˆ]"
            elif any(isinstance(attr, DocumentAttributeAudio) for attr in attrs):
                return "[ØµÙˆØª]"
            else:
                return "[Ù…Ø³ØªÙ†Ø¯]"
        else:
            return "[Ù…ÙŠØ¯ÙŠØ§]"
    else:
        return message.text or "[Ù…Ø­ØªÙˆÙ‰ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…]"

# Ø¯Ø§Ù„Ø© ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§
def format_message(action_type, sender, original_text, new_text=None, username=None, message_date=None):
    formatted = f"ğŸ“¢ {action_type} Ù…Ù†: {sender or 'Ù…Ø¬Ù‡ÙˆÙ„'}\n"
    if action_type == "ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø±Ø³Ø§Ù„Ø©":
        formatted += f"\nğŸ“ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù‚Ø¨Ù„ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„:\n{original_text}\n\nâœ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„:\n{new_text}"
    elif action_type == "ØªÙ… Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø©":
        formatted += f"\nğŸ—‘ Ø§Ù„Ù…Ø­ØªÙˆÙ‰: {original_text or 'Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ØºÙŠØ± Ù…Ø­ÙÙˆØ¸ØŒ Ø±Ø¨Ù…Ø§ Ø§Ù„Ø¨ÙˆØª Ø¨Ø¯Ø£ Ø¨Ø¹Ø¯ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.'}"
    else:
        formatted += f"\n{original_text}"
    formatted += f"\n\nØ§Ù„ÙŠÙˆØ²Ø±: {username or 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}\nØ§Ù„ÙˆÙ‚Øª: {message_date or format_datetime(datetime.now())}"
    return formatted

@client.on(events.NewMessage(incoming=True))
async def new_message_handler(event):
    sender = await event.get_sender()
    if not event.is_private or sender is None or getattr(sender, "bot", False):
        return

    message_id = event.message.id
    messages_dict[message_id] = event.message

@client.on(events.MessageEdited)
async def edit_handler(event):
    if not event.is_private:
        return

    sender = await event.get_sender()
    if sender is None or getattr(sender, "bot", False):
        return

    old_message = messages_dict.get(event.message.id)
    sender_name = f"{sender.first_name or ''} {sender.last_name or ''}".strip()
    username = f"@{sender.username}" if sender.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
    message_date = event.message.date.strftime("%Y-%m-%d %H:%M:%S")

    original_text = get_content_text(old_message) if old_message else "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"
    new_text = get_content_text(event.message)

    text = format_message("ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø±Ø³Ø§Ù„Ø©", sender_name, original_text, new_text, username, message_date)
    await client.send_message(forward_to_user, text)

    messages_dict[event.message.id] = event.message

@client.on(events.MessageDeleted)
async def delete_handler(event):
    for msg_id in event.deleted_ids:
        old_message = messages_dict.get(msg_id)
        if old_message is None or not old_message.is_private:
            continue

        sender = await old_message.get_sender()
        if sender is None:
            continue

        sender_name = f"{sender.first_name or ''} {sender.last_name or ''}".strip()
        username = f"@{sender.username}" if sender.username else "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
        message_date = old_message.date.strftime("%Y-%m-%d %H:%M:%S")

        content = get_content_text(old_message)
        text = format_message("ØªÙ… Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø©", sender_name, content, username=username, message_date=message_date)
        await client.send_message(forward_to_user, text)

async def main():
    keep_alive()  # ÙŠØ´ØºÙ„ Ø§Ù„Ø³ÙŠØ±ÙØ± Ø§Ù„ØµØºÙŠØ±
    await client.start()
    print("âœ… Ø§Ù„Ø¨ÙˆØª Ø´ØºØ§Ù„ ÙˆØ¨ÙŠØ±Ø§Ù‚Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ...")
    await client.run_until_disconnected()

if __name__ == "__main__":
    asyncio.run(main())
